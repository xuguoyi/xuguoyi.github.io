# 时间复杂度和空间复杂度
例如： 我们常说：代码跑起来占内存 100M，耗时 100 毫秒
> 衡量代码好坏有两个非常重要的标准就是：**运行时间和占用空间**，就是时间复杂度和空间复杂度

## 时间复杂度
- 代码的执行次数

### O(1)
一般情况下，只要算法里没有循环和递归，就算有上万行代码，时间复杂度也是 O(1)，因为它的执行次数不会随着任何一个变量的增大而变长
```javascript
function foo(){
    let n = 1
    let b = n * 100
    if(b === 100){
        console.log("开始吃糖")
    }
    console.log("我吃了1颗糖")
    console.log("我吃了2颗糖")
    ......
    console.log("我吃了10000颗糖")
}
```

### O(n)
总的来说 只有一层循环或者递归等
```javascript
function foo1(n){
    for( let i = 0; i < n; i++){
        console.log("我吃了一颗糖")
    }
}
function foo2(n){
    while( --n > 0){
        console.log("我吃了一颗糖")
    }
}
function foo3(n){
    console.log("我吃了一颗糖")
    --n > 0 && foo3(n)
}
```

### O(n²)
比如嵌套循环，如下面这样的，里层循环执行 n 次，外层循环也执行 n 次，总执行次数就是 n x n，时间复杂度就是 n 的平方，也就是 O(n²)。假设 n 是 10，那么里面的就会打印 10 x 10 = 100 次

```javascript
function foo1(n){
    for( let i = 0; i < n; i++){
        for( let j = 0; j < n; j++){
            console.log("我吃了一颗糖")
        }
    }
}
```

还有这样的，总执行次数为 n + n²，上面说了，如果是多项式，取最高次项，所以这个时间复杂度也是 O(n²)
```javascript
function foo2(n){
    for( let k = 0; k < n; k++){
        console.log("我吃了一颗糖")
    }
    for( let i = 0; i < n; i++){
        for( let j = 0; j < n; j++){
            console.log("我吃了一颗糖")
        }
    }
}

//或者下面这样，以运行时间最长的，作为时间复杂度的依据，所以下面的时间复杂度就是 O(n²)
function foo3(n){
    if( n > 100){
        for( let k = 0; k < n; k++){
            console.log("我吃了一颗糖")
        }
    }else{
        for( let i = 0; i < n; i++){
            for( let j = 0; j < n; j++){
                console.log("我吃了一颗糖")
            }
        }
    }
}
```

### O(logn)
例子：一包糖里有16颗，沐华每天吃这一包糖的一半，请问多少天吃完？
```javascript
function foo1(n){
    let day = 0
    while(n > 1){
        n = n/2
        day++
    }
    return day
}
console.log( foo1(16) ) // 4

// 或者
function foo2(n){
    for(let i = 0; i < n; i *= 2){
        console.log("一天")
    }
}
foo2( 16 )
```

其他还有一些时间复杂度，由快到慢排列了一下，如下表顺序

| 复杂度 | 名称 |
| ---- | ---- |
| O(1) | 常数复杂度 |
| O(logn)| 对数复杂度 |
| O(n) | 线性时间复杂度|
| O(nlogn) | 线性对数复杂度 |
| O(n²) | 平方 |
| O(n³) | 立方 |
| O(2^n) | 指数，一点数据量就卡的不行 |
| O(n!) | 阶乘，就更慢了 |

> 随着数据量或者 n 的增大，时间复杂度也随之增加，也就是执行时间的增加，会越来越慢，越来越卡

> 总的来说时间复杂度就是执行时间增长的趋势，那么空间复杂度就是存储空间增长的趋势

## 空间复杂度
算法需要多少内存，占用了多少空间

### O(1)
只要不会因为算法里的执行，导致额外的空间增长，就算是一万行，空间复杂度也是 O(1)，比如下面这样，时间复杂度也是 O(1)
- 同时间复杂度的O(1)的例子

### O(n)
n 的数值越大，算法需要分配的空间就需要越多，来存储数组里的值，所以它的空间复杂度就是 O(n)，时间复杂度也是 O(n)
- 同时间复杂度的O(n)的例子

### O(n²)
一般出现在比如二维数组，或是矩阵的情况下
```javascript 
// 遍历生成类似这样格式的
let arr = [
    [1,2,3,4,5],
    [1,2,3,4,5],
    [1,2,3,4,5]
]
```

## 常见的关于时间复杂度的面试题
#### 「二叉树的遍历-前序、中序、后序：时间复杂度是多少？」
答案是：「O(n)」，这里的n代表二叉树里边树的节点的总数，不管是哪种方式遍历，每个节点都有且仅访问一次，所以它的复杂度是线性于二叉树的节点总数，也就是O(n)

#### 「图的遍历：时间复杂度是多少？」
答案：「O(n)」，图中的每一个节点也是有且仅访问一次，因此时间复杂度也是O(n)，n为图中的节点总数

#### 「搜索算法：DFS(深度优先)、BFS(广度优先)时间复杂度是多少？」
答案：「O(n)」，后边的文章会详细介绍这两种算法(n为搜索空间中的节点总数)

#### 「二分查找：时间复杂度是多少？」
答案：「O(logn)」
